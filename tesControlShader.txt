#version 460 core

layout(location=0) uniform mat4 MVP;
layout(location=1) uniform mat4 M;
layout(location=7) uniform mat4 V;
layout (location=5) uniform vec3 camPos;


layout (vertices = 3) out;

in vec4 fcolor[];
in vec4 fpos[];
in vec4 fcubeTexCoord[];
in vec4 fnorm[];
flat in int fTextType[];


patch out vec4 tescontrol_color;
out vec4 tescontrol_pos[];
out vec4 tescontrol_norm[];
patch out int tescontrol_TextType;



void main(){

	//TODO gestionar valores segun la distancia de la camara

	gl_out[gl_InvocationID].gl_Position = gl_in[gl_InvocationID].gl_Position;
	
	tescontrol_color = fcolor[gl_InvocationID];
	tescontrol_pos[gl_InvocationID] = fpos[gl_InvocationID];
	tescontrol_norm[gl_InvocationID] = fnorm[gl_InvocationID];
	tescontrol_TextType = fTextType[gl_InvocationID];

	
if (gl_InvocationID == 0)
    {
		
		//float angle = acos(dot(camPos, fpos[0].xyz) / (length(camPos) * length(fpos[0].xyz)));
		
		vec4 center = (fpos[0] + fpos[1] + fpos[2]) / 3.0;
		
		center = V * center;
		
		float dist = -center.z;
			
        if(dist >= -4 && dist < 4){

		gl_TessLevelOuter[0] = 64; 
        gl_TessLevelOuter[1] = 64; 
        gl_TessLevelOuter[2] = 64; 
        
        gl_TessLevelInner[0] = 64;
		}else if(dist >=4 && dist < 8){
		gl_TessLevelOuter[0] = 32; 
        gl_TessLevelOuter[1] = 32; 
        gl_TessLevelOuter[2] = 32; 
        
        gl_TessLevelInner[0] = 32;
		}else if(dist >=8 && dist < 12){
		gl_TessLevelOuter[0] = 16; 
		gl_TessLevelOuter[1] = 16; 
		gl_TessLevelOuter[2] = 16; 
		
		gl_TessLevelInner[0] = 16;
		}else if(dist >=12){
		gl_TessLevelOuter[0] = 8;
		gl_TessLevelOuter[1] = 8;
		gl_TessLevelOuter[2] = 8;
		
		gl_TessLevelInner[0] = 8;
		}
    }


    
}


